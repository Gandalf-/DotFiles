#!/bin/bash

# super git wrapper!

[[ -z $1 ]] && { g --help; exit 1; }

cnfrm=1
fmt="\
%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset"

while [[ $1 ]]; do
  case "$1" in
    !)  cnfrm=$(( ! cnfrm ))                                    ;;
    a)  confirm! "$cnfrm" "git add -A :/" ;;
    bv) confirm! "$cnfrm" "git branch -vv" ;;
    rv) confirm! "$cnfrm" "git remote -vv" ;;
    f)  confirm! "$cnfrm" "git fetch" ;;

    c)  confirm! "$cnfrm" "git commit" ;;
    ca) confirm! "$cnfrm" "git commit --amend" ;;
    cn) confirm! "$cnfrm" "git commit --amend --no-edit" ;;

    co) confirm! "$cnfrm" "git checkout \"$2\""; shift ;;
    cb) confirm! "$cnfrm" "git checkout -b \"$2\""; shift ;;
    s)  confirm! "$cnfrm" "git status" ;;

    ri) confirm! "$cnfrm" "git rebase -i \"$2\""; shift ;;
    cm) confirm! "$cnfrm" "git commit -m \"$2\""; shift ;;
    m)  confirm! "$cnfrm" "git merge \"$2\""    ; shift ;;

    pm) confirm! "$cnfrm" "git pull \"${2%.}\""          ; shift ;;
    pl) confirm! "$cnfrm" "git pull --no-edit \"${2%.}\""; shift ;;

    ph) confirm! "$cnfrm" "git push \"${2%.}\""; shift ;;
    pf) confirm! "$cnfrm" "git push --force \"${2%.}\""; shift ;;

    cc) confirm! "$cnfrm" "git clean -nfd"
        confirm "$cnfrm" "Continue?"
        git clean -fd                                           ;;

    cs) branch=$(git branch -q | grep -i "$2" | xargs | cut -f1 -d' ')
        confirm "cnfrm" "git checkout $branch"
        git checkout "$branch"; shift                           ;;

    l)  confirm "$cnfrm" "git log"
        git log --color=always | head -n 20                     ;;

    lo) confirm "$cnfrm" "git log --oneline"
        git log --oneline --color=always | head -n 10           ;;

    ll) confirm "$cnfrm" "git log --graph"
        git log --graph --pretty=format:"$fmt" --abbrev-commit  ;;

    d)  if [[ -f $2 ]]; then
            confirm "$cnfrm" "git diff --full-index > $2"
            git diff --full-index > "$2"
            shift

          else
            confirm "$cnfrm" "git diff --full-index"
            git diff --full-index
          fi
      ;;

    dh) if [ "$2" -eq "$2" ] 2>/dev/null ; then
            commits="$2"
          else
            commits="1"
          fi

          if [[ -f "$3" ]]; then
            confirm "$cnfrm" "git diff --full-index HEAD~$commits > $3"
            git diff --full-index HEAD~"$commits" > "$3"
            shift

          else
            confirm "$cnfrm" "git diff --full-index HEAD~$commits"
            git diff --full-index HEAD~"$commits"
          fi
          shift
      ;;

    ds) [[ -z "$DIFFDIR" ]] && {
            echo "error: smart diff not available"
            exit 1
          }
          branch="$(git rev-parse --abbrev-ref HEAD)"
          diff="$DIFFDIR/${branch}.diff"

          if [ "$2" -eq "$2" ] 2>/dev/null ; then # checks if $2 is a number
            confirm "$cnfrm" "git diff --full-index HEAD~$2 > $diff"
            git diff --full-index HEAD~"$2" > "$diff"
            shift

          else
            confirm "$cnfrm" "git diff --full-index HEAD~1 > $diff"
            git diff --full-index HEAD~1 > "$diff"
            shift
          fi
      ;;

    bn) confirm "$cnfrm" "git checkout $remote_branch -b $new_branch_name"
          remote_branch="$2"
          new_branch_name="$3"
          git checkout "$remote_branch" -b "$new_branch_name"
          shift; shift
      ;;

    *)
      echo "
  g - super git wrapper
    !  : toggle confirmation
    a  : add everything
    bv : branch -vv
    bn : checkout (remote branch) -b (local branch)
    cc : clean -nfd, confirm, clean -fd
    c  : commit
    ca : commit --amend
    cn : commit --amend --no-edit
    cb : checkout -b (branch)
    cs : attempt to checkout branch by bug name [work only]
    cm : commit -m (message)
    co : checkout (file)
    d  : diff changes [output_file]
    dh : diff commits [number of commits] [output_file]
    ds : diff commits [number of commits] - auto names diff [work only]
    f  : fetch
    l  : log
    ll : log graph
    m  : merge (branch)
    s  : status
    rv : remote -vv
    ri : interactive rebase
    p  : pause
    pl : pull --no-edit [branch]
    pm : pull [branch]
    ph : push [branch]
    pf : push --force [branch]
      "
      exit 1
      ;;
  esac

  (( $? )) && { confirm 0 "Detected failure, not continuing"; exit 1; }
  shift

  [[ -z "$1" ]] || echo
done
