#!/bin/bash

# Script that compresses and encrypts directories or files with openssl and zip
# also handles the reverse process to restore the files. Works on files and
# directories, don't have to be in the current working directory
#
# requires: openssl, md5sum, zip or tar
# author: leaf@anardil.net

# catch undefined variables
set -u
# pass errors up through pipelines so they aren't ignored
set -o pipefail


# compress and then aes256 encrypt
# =============================
function encrypt() {

  # try to catch encrypting files/ directories outside of current working directory. this
  # is a problem because unzip recreates the directory structure instead of merging  output
 
  if test $(dirname $file) != "." ; then
    echo "!!! qcrypt encryption should not be run on files outside of the current working
    directory. Please move to the directory containing the file and run again."
    exit 1
  fi

  # try to catch attempted re-encryption
  if test "${file: -8}" == ".zaes256" || test "${file: -8}" == ".taes256" ; then
    echo "??? $file appears to already be encrypted by qcrypt."
    read -p "    Are you sure you want to continue? (y/n) " -n 2 -r ; echo

    if test "$REPLY" != "y" ; then exit ; fi
  fi

  # create an md5sum of the directory or file and creation date file
  sum=$(find $file -type f -exec md5sum {} \; | sort -k 34 | md5sum | cut -c 1-32)
  echo $sum > md5sum.qcrypt
  echo $(date) > date.qcrypt

  # compress the directory with tar
  if test "$tar" == 1 ; then
    in_extension=".tar" ; out_extension=".taes256"
    tar -zcf "$file."tar *.qcrypt "$file" >/dev/null

  # compress the directory with zip, default
  else
    in_extension=".zip" ; out_extension=".zaes256"
    zip -r "$file".zip *.qcrypt "$file" >/dev/null
  fi
  
  # check for compression failure
  if test "$?" != 0 ; then
    echo "!!! Compression failed, not continuing."
    rm *.qcrypt
    exit 1
  fi

  # warn if output file will overwrite existing file
  if [[ -e "$file""$out_extension" ]] ; then
    read -p "??? \"$file$out_extension\" already exists. Overwrite? (y/n) " -n 2 -r ; echo

    # no overwrite, clean up and exit
    if test "$REPLY" != 'y' && test "$REPLY" != 'Y' ; then 
      rm -f "$file""$in_extension" *.qcrypt
      exit
    fi

    # overwrite, remove previous version
    rm -f "$file""$out_extension"
  fi

  # encrypt with openssl and aes256
  openssl aes256 -in "$file""$in_extension" -out "$file""$out_extension" -salt 2>/dev/null

  # check for encryption failure
  if test "$?" != 0 ; then
    echo "!!! Encryption failed, not continuing."
    rm -rf "$file""$in_extension" *.qcrypt 
    exit 1
  fi

  # set output to read only and cleanup working files
  chmod 400 "$file""$out_extension"
  rm -rf "$file" "$file""$in_extension" *.qcrypt

  if test "$?" != 0 ; then
    echo "!!! Cleanup failed, please check the directory for extra files."
    exit 1
  fi

  echo "+++ Encryption completed. Output file is $file$out_extension"
}


# aes256 decrypt and decompress
# =============================
function decrypt() {
  # check if file name is long enough for qcrypt extension check
  if [ ${#file} -le 8 ] ; then
    file_extension=""
  else
    file_extension=${file: -8}
  fi

  # check for tar usage 
  if test "$file_extension" == ".taes256" ; then
    in_extension=".tar" ; out_extension=".taes256"
    output_file=${file::-8} ; nonstandard=0

  # check for zip usage
  elif test "$file_extension" == ".zaes256" ; then
    in_extension=".zip" ; out_extension=".zaes256"
    output_file=${file::-8} ; nonstandard=0

  # target has non standard extension, determine compression 
  else
    # try to catch attempted re-encryption
    echo "??? $file doesn't appear to be encrypted by qcrypt."
    read -p "    Are you sure you want to continue? (y/n) " -n 2 -r ; echo

    if test "$REPLY" != "y" ; then exit ; fi

    # user says they know what they're doing, use input file name as output
    output_file="$file".out ; nonstandard=1

    if test "$tar" == 1 ; then
      in_extension=".tar" ; out_extension=".taes256"

    # zip is the default
    else
      in_extension=".zip" ; out_extension=".zaes256"
    fi
  fi

  # decrypt with openssl
  openssl aes256 -d -in "$file" -out "$file""$in_extension" -salt 2>/dev/null

  # check for decryption failure
  if test "$?" != 0 ; then
    echo "!!! Decryption failed, not continuing."
    rm -f "$file""$in_extension"
    exit 1
  fi

  # non standard skips overwrite checks
  if test "$nonstandard" != 1 ; then
    echo "??? Cannot verify file integrity of files or that output will not overwrite an existing file"

  # check if file with output name already exists
  else
    if [[ -e "$output_file" ]] ; then
      read -p "??? File or directory \"$output_file\" already exists. Overwrite? (y/n) " -n 2 -r
      echo

      # no overwrite, cleanup and exit
      if test "$REPLY" != 'y' && test "$REPLY" != 'Y' ; then 
        rm -f "$file""$in_extension"
        exit
      fi

      # overwrite, remove previous version
      rm -rf $output_file
    fi
  fi

  # decompress the output, with zip
  if test "$in_extension" == ".zip" ; then

    if test "$(which unzip)" == "" ; then
      echo "!!! Decompression failed, can't find compression program used with this archive."
      rm -f "$file""$in_extension"
      exit 1

    else
      unzip "$file".zip >/dev/null 2>/dev/null
    fi

  # decompress the output, with tar
  else
    if test "$(which tar)" == "" ; then
      echo "!!! Decompression failed, can't find compression program used with this archive."
      rm -f "$file""$in_extension"
      exit 1

    else
      tar -xf "$file".tar >/dev/null 2>/dev/null
    fi
  fi

  # check for decompression failure
  if test "$?" != 0 ; then
    echo "!!! Decompression failed, not continuing."
    rm -f "$file""$in_extension"
    exit 1
  fi

  # attempt to grab date of encryption
  date="date information not found"
  if [[ -e "date.qcrypt" ]] ; then date=$(cat date.qcrypt) ; fi

  # verify that md5sum has not changed, this is skipped for non standard files
  if test "$nonstandard" != 1 ; then
    sum=$(find $output_file -type f -exec md5sum {} \; | sort -k 34 | md5sum | cut -c 1-32) 

    if [[ -e "md5sum.qcrypt" ]] ; then

      if test "$(cat md5sum.qcrypt)" != $sum ; then
        echo "!!! File integrity checks failed."
        rm -f "$file""$in_extension" *.qcrypt
        exit 1
      fi

    else
      echo "??? Cannot find file integrity check, unable to verify integrity."
    fi
  fi

  # clean up the working files
  rm -rf "$file" "$file""$in_extension" *.qcrypt

  if test "$?" != 0 ; then
    echo "!!! Cleanup failed, please check the directory for extra files."
    exit 1
  fi

  echo "+++ Decryption completed. Archive was created on: $date"
}


# check for dependencies
#==============================
# check for openssl
if test "$(which openssl)" == "" ; then
  echo "!!! Could not find required program: openssl" ; echo
  exit 1
fi

# check for md5sum
if test "$(which md5sum)" == "" ; then
  echo "!!! Could not find required program: md5sum" ; echo
  exit 1
fi

# check for compression program, prefer zip, this can be overridden with flags
tar=0
if test "$(which zip)" == "" ; then

  # check for tar if can't find zip
  if test "$(which tar)" == "" ; then
    echo "!!! Could not find suitable compression program." ; echo
    exit 1

  else
    tar=1
  fi
fi


# run
#============================
arg1=${1:-} ; arg2=${2:-} ; arg3=${3:-} ; arg4=${4:-}

# usage
if test "$arg1" != "-a" && test "$arg1" != "-e" && test "$arg1" != "-d" ; then
  echo "usage: qcrypt (-a|-e|-d) [-z|-t] target_name"
  exit
fi

# compression program specified
if test "$arg2" == "-z" || test "$arg2" == "-t" ; then

  if test "$arg2" == "-z" ; then tar=0 ; else tar=1 fi
  filearg=$arg3

  # warn that only one directory or file is handled per run
  if test "$arg4" != "" ; then
    echo "!!! qcrypt only handles one file or directory at a time"
    exit 1
  fi

# compression program not specified
else
  filearg=$arg2

  # warn that only one directory or file is handled per run
  if test "$arg3" != "" ; then
    echo "!!! qcrypt only handles one file or directory at a time"
    exit 1
  fi
fi

# check if target file exists
if test "$filearg" == "" ; then
  echo "usage: qcrypt [-a|-e|-d] [-z|-t] directory_name"
  exit
fi

if ! [[ -e "$filearg" ]] ; then
  echo "!!! File provided does not exist, not continuing."
  exit 1
fi

# remove trailing slash, if any
file=${filearg%/}

if test "$arg1" == "-e" ; then
  encrypt ; exit

elif test "$arg1" == "-d" ; then
  decrypt ; exit

# auto detect
else
  # check if file name is long enough for qcrypt extension check
  if [ ${#file} -le 8 ] ; then
    auto_extension=""
  else
    auto_extension=${file: -8}
  fi

  if test "$auto_extension" == ".zaes256" || test "$auto_extension" == ".taes256" ; then
    echo "Attempting decryption" ; decrypt ; exit
  else
    echo "Attempting encryption" ; encrypt ; exit
  fi
fi
