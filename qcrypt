#!/bin/bash

# Script that compresses and encrypts directories or files with openssl and zip
# also handles the reverse process to restore the files. Works on files and
# directories, don't have to be in the current working directory
#
# requires: openssl, md5sum, zip or tar
# author  : leaf@anardil.net

set -u -o pipefail
usage="usage: $0 (-a|-e|-d) [-z|-t] (directory)"
error () { for msg in "$@"; do echo "$msg"; done; exit 1; }

# compress and then aes256 encrypt
# =============================
function encrypt() {

  tar="$1"
  file="$2"
  local sum in_ext out_ext

  [[ "$(dirname "$file")" != "." ]] && {
    error \
      "!!! qcrypt encryption should not be run on files outside of the    " \
      "current working directory. Please move to the directory containing " \
      "the file and run again.                                            "
  }

  # try to catch attempted re-encryption
  [[ "${file: -8}" == ".zaes256" || "${file: -8}" == ".taes256" ]] && {
    echo    "??? $file appears to already be encrypted by qcrypt."
    read -p "    Are you sure you want to continue? (y/n) " -n 2 -r
    [[ 'Yy' =~ $REPLY ]] || exit
  }

  # create an md5sum of the directory or file and creation date file
  sum=$(find "$file" -type f -exec md5sum {} \; |
        sort -k 34 | md5sum | cut -c 1-32)
  echo "$sum" > md5sum.qcrypt
  date        > date.qcrypt

  if (( tar )) ; then
    in_ext=".tar" ; out_ext=".taes256"
    tar -zcf "$file."tar ./*.qcrypt "$file" >/dev/null

  else
    in_ext=".zip" ; out_ext=".zaes256"
    zip -r "$file".zip ./*.qcrypt "$file" >/dev/null
  fi

  (( $? )) && {
    rm ./*.qcrypt
    error "!!! Compression failed, not continuing."
  }

  [[ -e "$file""$out_ext" ]] && {
    read -p "??? \"$file$out_ext\" already exists. Overwrite? (y/n) " -n 2 -r

    [[ 'Yy' =~ $REPLY ]] || {
      rm -f "$file""$in_ext" ./*.qcrypt
      exit
    }

    # remove old version
    rm -f "$file""$out_ext"
  }

  # encrypt with openssl and aes256
  if [[ "${QCRYPT_MODE:-}" == "TEST" ]]; then
    echo "!!! qcrypt test mode"
    openssl aes256 -in "$file""$in_ext" -out "$file""$out_ext" -salt -k "default"

  else
    openssl aes256 -in "$file""$in_ext" -out "$file""$out_ext" -salt 2>/dev/null
  fi

  # check for encryption failure
  (( $? )) && {
    rm -rf "$file""$in_ext" ./*.qcrypt
    error "!!! Encryption failed, not continuing."
  }

  # set output to read only and cleanup working files
  chmod 400 "$file""$out_ext"
  rm -rf "$file" "$file""$in_ext" ./*.qcrypt
  (( $? )) && error "!!! Cleanup failed, check for extra files."

  echo "+++ Encryption completed. Output file is $file$out_ext"
}


# aes256 decrypt and decompress
# =============================
function decrypt() {

  tar="$1"
  file="$2"
  local file_ext in_ext out_ext out_file nonstandard date sum

  nonstandard=0
  in_ext=".zip"
  out_ext=".zaes256"
  date="date information not found"
  file_ext=""; [[ ${#file} -gt 8 ]] && file_ext=${file: -8}

  # determine compression to use
  case $file_ext in
    '.taes256') out_file=${file::-8}; in_ext=".tar"; out_ext=".taes256";;
    '.zaes256') out_file=${file::-8} ;;
    *)
      # try to catch attempted re-encryption
      echo    "??? $file doesn't appear to be encrypted by qcrypt. "
      read -p "    Are you sure you want to continue? (y/n) " -n 2 -r
      [[ 'Yy' =~ $REPLY ]] || exit

      out_file="$file" ; nonstandard=1
      (( tar )) && { in_ext=".tar"; out_ext=".taes256"; }
      ;;
  esac

  # decrypt with openssl
  if [[ "${QCRYPT_MODE:-}" == "TEST" ]]; then
    echo "!!! qcrypt test mode"
    openssl aes256 -d -in "$file" -out "$file""$in_ext" -salt -k "default"

  else
    openssl aes256 -d -in "$file" -out "$file""$in_ext" -salt 2>/dev/null
  fi

  # check for decryption failure
  (( $? )) && {
    rm -f "$file""$in_ext"
    error "!!! Decryption failed, not continuing."
  }

  # non standard skips overwrite checks
  if (( nonstandard )); then
    echo "??? Cannot verify file integrity of files or that output will
          not overwrite an existing file"

  # check if file with output name already exists
  else
    [[ -e "$out_file" ]] && {
      read -n 2 -r -p "??? \"$out_file\" already exists. Overwrite?  "

      # overwrite or cleanup and exit
      [[ 'Yy' =~ $REPLY ]] || { rm -f "$file""$in_ext"; exit; }
    }
  fi

  # overwrite, remove previous version
  rm -rf "$out_file"

  # decompress the output
  case $in_ext in
    '.zip') unzip   "$file".zip >/dev/null 2>/dev/null ;;
    *)      tar -xf "$file".tar >/dev/null 2>/dev/null ;;
  esac

  # check for decompression failure
  (( $? )) && {
    rm -f "$file""$in_ext"
    error "!!! Decompression failed, not continuing."
  }

  # attempt to grab date of encryption
  [[ -e "date.qcrypt" ]] && date=$(cat date.qcrypt)

  # verify that md5sum has not changed, this is skipped for non standard files
  (( ! nonstandard )) && {

    sum=$(find "$out_file" -type f -exec md5sum {} \; |
          sort -k 34 | md5sum | cut -c 1-32)

    if [[ -e "md5sum.qcrypt" ]]; then

      [[ "$(cat md5sum.qcrypt)" != "$sum" ]] && {
        rm -f "$file""$in_ext" ./*.qcrypt
        error "!!! File integrity checks failed."
      }

    else
      echo "??? Cannot find file integrity check, unable to verify integrity."
    fi
  }

  # clean up the working files
  rm -rf "$file" "$file""$in_ext" ./*.qcrypt
  (( $? )) && error "!!! Cleanup failed, check for extra files."

  echo "+++ Decryption completed. Archive was created on: $date"
}


main () {

  local tar file filearg auto_ext
  tar=0

  [[ -z "$(which openssl)" ]] && error "!!! Requires openssl"
  [[ -z "$(which md5sum)"  ]] && error "!!! Requires md5sum"
  [[ -z "$(which zip)" && -z "$(which tar)" ]] && error "!!! Requires zip or tar"

  # usage
  arg1=${1:-} ; arg2=${2:-} ; arg3=${3:-} ; arg4=${4:-}
  [[ $arg1 =~ -a|-e|-d ]] || error "$usage"

  # compression program specified
  if [[ $arg2 =~ -z|-t ]]; then

    [[ "$arg2" == "-t" ]] && tar=1
    filearg="$arg3"
    [[ -z "$arg4" ]] || error "!!! qcrypt only handles one directory at a time"

  # compression program not specified
  else
    filearg="$arg2"
    [[ -z "$arg3" ]] || error "!!! qcrypt only handles one directory at a time"
  fi

  # check if target exists
  [[ -z "$filearg" ]] && error "$usage"
  [[ -e "$filearg" ]] || error "!!! File provided does not exist."

  # remove trailing slash, if any
  file=${filearg%/}

  case $arg1 in
    '-e') encrypt "$tar" "$file" ;;
    '-d') decrypt "$tar" "$file" ;;
    *)
      # check if file name is long enough for qcrypt ext check
      auto_ext=${file: -8}; [[ ${#file} -le 8 ]] && auto_ext=""

      case $auto_ext in
        '.zaes256'|'.taes256')
          echo "Attempting decryption"; decrypt "$tar" "$file" ;;
        *)
          echo "Attempting encryption"; encrypt "$tar" "$file" ;;
      esac
      ;;
  esac
}

main "$@"
