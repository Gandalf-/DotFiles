" vi: ft=vim

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Plugins
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
  " Vundle
    let has_vundle=1
    let vundle_url='https://github.com/VundleVim/Vundle.vim'

    if !filereadable(expand('~/.vim/bundle/Vundle.vim/README.md'))
      silent !mkdir -p ~/.vim/bundle
      silent exe "!git clone " . g:vundle_url . " ~/.vim/bundle/Vundle.vim"
      let has_vundle=0
    endif

    filetype off
    set runtimepath+=~/.vim/bundle/Vundle.vim

    try
      call vundle#begin()
        Plugin 'VundleVim/Vundle.vim'

        Plugin 'benmills/vimux'
        Plugin 'christoomey/vim-tmux-navigator'
        Plugin 'junegunn/fzf'
        Plugin 'junegunn/fzf.vim'

        if dimension == "work"
          Plugin 'Shougo/neocomplete.vim'
          Plugin 'Shougo/neoinclude.vim'
          Plugin 'Shougo/neosnippet-snippets'
          Plugin 'Shougo/neosnippet.vim'
        else
          Plugin 'zxqfl/tabnine-vim'
        endif

        Plugin 'vimwiki/vimwiki'
        Plugin 'w0rp/ale'
        Plugin 'dag/vim2hs'
        " Plugin 'nbouscal/vim-stylish-haskell'
        Plugin 'ehamberg/vim-cute-python'
        Plugin 'Gandalf-/vim-sh-syntax'
        Plugin 'justinmk/vim-syntax-extra'
        Plugin 'tpope/vim-fugitive'
        Plugin 'tpope/vim-sleuth'
        Plugin 'simnalamburt/vim-mundo.git'

        if has_vundle == 0
          :PluginInstall
        endif
      call vundle#end()
    catch
    endtry
    filetype plugin indent on

  " vimux
    let g:VimuxOrientation = "h"
    let g:VimuxHeight = "33"

  " fzf
    " Customize fzf colors to match your color scheme
    let g:fzf_colors =
    \ { 'fg':      ['fg', 'Normal'],
      \ 'bg':      ['bg', 'Normal'],
      \ 'hl':      ['fg', 'Comment'],
      \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
      \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
      \ 'hl+':     ['fg', 'Statement'],
      \ 'info':    ['fg', 'PreProc'],
      \ 'border':  ['fg', 'Ignore'],
      \ 'prompt':  ['fg', 'Conditional'],
      \ 'pointer': ['fg', 'Exception'],
      \ 'marker':  ['fg', 'Keyword'],
      \ 'spinner': ['fg', 'Label'],
      \ 'header':  ['fg', 'Comment'] }

    let g:fzf_action = {
      \ 'ctrl-x': 'split',
      \ 'ctrl-v': 'vsplit' }

  " vimwiki
    "autocmd TextChanged,TextChangedI *.md silent write
    let g:vimwiki_table_mappings = 0
    let g:vimwiki_url_maxsave    = 0
    let g:vimwiki_global_ext     = 0
    let g:vimwiki_folding        = 'custom'

    let g:vimwiki_root = '~/wiki'
    let g:vimwiki_list = [{
          \ 'path': '~/wiki/',
          \ 'syntax': 'markdown',
          \ 'ext': '.md'}]

    if dimension == "work"
      " work settings

      let g:ale_fixers = {
      \   '*': ['remove_trailing_lines', 'trim_whitespace'],
      \   'haskell': ['hlint', 'stylish-haskell', 'remove_trailing_lines', 'trim_whitespace'],
      \   'python' : ['remove_trailing_lines', 'trim_whitespace']
      \}

    else
      let g:ale_fixers = {
      \   '*': ['remove_trailing_lines', 'trim_whitespace'],
      \   'haskell': ['hlint', 'stylish-haskell', 'remove_trailing_lines', 'trim_whitespace'],
      \   'python' : ['autopep8', 'remove_trailing_lines', 'trim_whitespace']
      \}
    endif

    autocmd BufNewFile,BufRead,BufEnter *.md set filetype=vimwiki

    nmap <Leader>wn <Plug>VimwikiNextLink
    nmap <Leader>wp <Plug>VimwikiPrevLink

    function! VimwikiLinkHandler(link)
      " Use Vim to open external files with the 'vfile:' scheme.  E.g.:
      "   1) [[vfile:~/Code/PythonProject/abc123.py]]
      "   2) [[vfile:./|Wiki Home]]
      let link = a:link
      if link =~# '^vfile:'
        let link = link[1:]
      else
        return 0
      endif
      let link_infos = vimwiki#base#resolve_link(link)
      if link_infos.filename == ''
        echomsg 'Vimwiki Error: Unable to resolve link!'
        return 0
      else
        exe 'Vexplore ' . fnameescape(link_infos.filename)
        return 1
      endif
    endfunction

  " neocomplete
    if exists("neocomplete#data_directory")
      "let g:acp_enableAtStartup = 0
      let g:neocomplete#enable_at_startup = 1
      let g:neocomplete#enable_smart_case = 1
      let g:neocomplete#sources#syntax#min_keyword_length = 3

      if !exists('g:neocomplete#keyword_patterns')
          let g:neocomplete#keyword_patterns = {}
      endif

      let g:neocomplete#auto_completion_start_length = 2
      let g:neocomplete#keyword_patterns['default']  = '\h\w*'
      let g:neocomplete#max_list = 5

      inoremap <expr><C-g> neocomplete#undo_completion()
      inoremap <expr><C-l> neocomplete#complete_common_string()

      " <CR>: close popup and save indent.
        inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
        function! s:my_cr_function()
          return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
        endfunction

      " <TAB>: completion.
        inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

      " <BS>: close popup and delete backword char.
        inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
    endif

  " neosnippet
    if exists("neosnippet#data_directory")
      imap <C-l> <Plug>(neosnippet_expand_or_jump)
      smap <C-l> <Plug>(neosnippet_expand_or_jump)
      xmap <C-l> <Plug>(neosnippet_expand_target)

      imap <C-j> <Plug>(neosnippet_jump)
      smap <C-j> <Plug>(neosnippet_jump)

      imap <expr><TAB>
       \ pumvisible() ? "\<C-n>" :
       \ neosnippet#expandable_or_jumpable() ?
       \    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

      let g:neosnippet#snippets_directory = [ "~/.vim/snippets", "~/.vim/bundle/neosnippet-snippets/neosnippets/" ]

      if has('conceal')
        set conceallevel=2 concealcursor=i
      endif
    endif

  " ALE
    let g:ale_fix_on_save = 1

    " let g:ale_lint_on_enter = 0
    let g:haskell_hlint_options = '-j'
    let g:ale_lint_on_text_changed = 'normal'
    let g:ale_lint_delay = 200
    let g:ale_linters = {
      \ 'python': ['pylint', 'flake8'],
      \ 'haskell': ['cabal_ghc', 'ghc', 'ghc_mod', 'hdevtools', 'hlint', 'stack_build', 'stack_ghc']
      \ }

    let g:ale_c_clang_options = "-std=c++11 -Wall"
    let g:ale_cpp_clangcheck_options = "-std=c++11 -Wall"

    let g:ale_set_quickfix = 1
    let g:ale_set_highlights = 0
    let g:ale_type_map = {'flake8': {'ES': 'WS', 'E': 'W'}}

    highlight link ALEWarningSign Comment
    highlight link ALEWarning Comment

    highlight link ALEErrorSign String
    highlight link ALEError String

    let g:ale_sign_error = 'X' " '✘'
    let g:ale_sign_warning = '>' " '▶'
    let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Miscellaneous
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

  " terminal!
  try
    nnoremap <leader>T :terminal fish<CR>
    tnoremap <silent> <C-h> <C-W>:TmuxNavigateLeft<cr>
    tnoremap <silent> <C-j> <C-W>:TmuxNavigateDown<cr>
    tnoremap <silent> <C-k> <C-W>:TmuxNavigateUp<cr>
    tnoremap <silent> <C-l> <C-W>:TmuxNavigateRight<cr>
  catch
  endtry

  " misc autocommands
  augroup misc_commands
    autocmd!

  " haskell format
    " autocmd FileType haskell setlocal formatprg=stylish-haskell

  " make uses tabs
    autocmd FileType make setlocal noexpandtab

  " Make pylint happy
    autocmd FileType c,cpp,python setlocal tabstop=4
    " autocmd BufNewFile,BufRead *.py setlocal tabstop=4
  augroup end

  " silver searcher-ing
    if executable('ag')
        set grepprg=ag\ --nogroup\ --nocolor\ --smart-case\ --column
        set grepformat=%f:%l:%c%m
    endif

    command! -nargs=+ -complete=file -bar Ag silent! grep! <args>|cwindow|redraw!
    nnoremap \ :Ag<SPACE>

  " Searching
    set hlsearch incsearch showmatch ignorecase smartcase infercase ruler

  " Search for visually selected text, forwards or backwards!
    vnoremap <silent> * :<C-U>
      \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
      \gvy/<C-R><C-R>=substitute(
      \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
      \gV:call setreg('"', old_reg, old_regtype)<CR>
    vnoremap <silent> # :<C-U>
      \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
      \gvy?<C-R><C-R>=substitute(
      \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
      \gV:call setreg('"', old_reg, old_regtype)<CR>

  " mouse!
    function! ToggleMouse()
        " check if mouse is enabled
        if &mouse == 'a'
            " disable mouse
            set mouse=
            echo "Mouse disabled"
        else
            " enable mouse everywhere
            set mouse=a
            echo "Mouse enabled"
        endif
    endfunc
    map <silent> <leader>b :call ToggleMouse()<cr>

    " scrolling like a GUI!
      map <ScrollWheelUp> 5<C-Y>
      map <ScrollWheelDown> 5<C-E>

  " Folding
    set foldtext=MyFoldText()
    function! MyFoldText()
      let nucolwidth = &fdc + &number*&numberwidth
      let winwd = winwidth(0) - nucolwidth - 5
      let foldlinecount = foldclosedend(v:foldstart) - foldclosed(v:foldstart) + 1
      let prefix = " >>> "
      let fdnfo = prefix . string(v:foldlevel) . "," . string(foldlinecount)
      let line =  strpart(getline(v:foldstart), 0 , winwd - len(fdnfo))
      let fillcharcount = winwd - len(line) - len(fdnfo)
      return line . repeat(" ",fillcharcount) . fdnfo
    endfunction
    set foldmethod=indent
    set foldnestmax=10
    set nofoldenable
    set foldlevel=2
    set foldcolumn=1

  " Cool file explorer stuff in a pane
    function! ToggleVExplorer()
        if exists("t:expl_buf_num")
            let expl_win_num = bufwinnr(t:expl_buf_num)
            if expl_win_num != -1
                let cur_win_nr = winnr()
                exec expl_win_num . 'wincmd w'
                close
                exec cur_win_nr . 'wincmd w'
                unlet t:expl_buf_num
            else
                unlet t:expl_buf_num
            endif
        else
            exec '1wincmd w'
            Vexplore .
            let t:expl_buf_num = bufnr("%")
        endif
    endfunction
    nnoremap <silent> <leader>d :call ToggleVExplorer()<CR>

  " Hit enter in the file browser to open the selected
  " file with :vsplit to the right of browser
    let g:netrw_sort_sequence = '[\/]$,*'   " directories first
    let g:netrw_browse_split  = 3           " open files in new tab
    let g:netrow_altv         = 1
    let g:netrw_winsize       = -28         " thinner width
    let g:netrw_banner        = 0           " hide the help info
    let g:netrw_liststyle     = 3           " tree mode
    let g:netrw_list_hide     = '.*\.swp$,.*\.pyc'

  " Clear junk before running commands
    noremap :! :!clear;
    noremap :make :!clear; make

  " Delete empty buffers
    function! DeleteEmptyBuffers()
      let [i, n; empty] = [1, bufnr('$')]
      while i <= n
          if bufexists(i) && bufname(i) == ''
              call add(empty, i)
          endif
          let i += 1
      endwhile
      if len(empty) > 0
          exe 'bdelete' join(empty)
      endif
    endfunction
